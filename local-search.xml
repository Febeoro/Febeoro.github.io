<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图网络基础——P2.3-小世界网络</title>
    <link href="/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2-3-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/"/>
    <url>/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2-3-%E5%B0%8F%E4%B8%96%E7%95%8C%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="小世界模型"><a href="#小世界模型" class="headerlink" title="小世界模型"></a>小世界模型</h3><h4 id="模型引入"><a href="#模型引入" class="headerlink" title="模型引入"></a>模型引入</h4><p>ER随机图中的聚类系数是一个很小的值，会随着节点数量的增加而持续减小。那么如何在确定最短路径的同时获得一个比较大的距离系数呢?</p><p>实际上，聚类系数反应的是边的局部特性，而ER图的聚类系数和真实网络的差距过大，我们举一个例子<br><img src="/images/16164143108969.jpg" alt=""><br>通过上面的例子可以发现，随机图计算出来的聚类系数和真实的聚类系数的数量级相差至少在 10^2 以上。</p><p>在网格网络中，我们实现了三角闭合和高聚类系数，但是平均路径长度较长。</p><p><img src="/images/16164850149259.jpg" alt="grid_network.png"></p><p>在随机网络中，我们实现了较短的平均路径长度，但聚类系数较低。</p><p><img src="/images/16164850351385.jpg" alt="random_network"></p><p>基于以上两个图结构，似乎不能直观地得到一个具有较短的平均路径长度，同时也具有较高的聚类系数的图。但是，大多数现实世界网络具有如下表所示的属性，其中 $h$ 是平均最短路径长度，$c$ 是平均聚类系数为，了便于比较，随机图的平均度与实际网络相同。</p><div class="table-container"><table><thead><tr><th style="text-align:center">网络类型</th><th style="text-align:center"><strong>$h_{actual}$</strong></th><th style="text-align:center"><strong>$h_{random}$</strong></th><th style="text-align:center"><strong>$c_{actual}$</strong></th><th style="text-align:center"><strong>$c_{random}$</strong></th></tr></thead><tbody><tr><td style="text-align:center">电影演员</td><td style="text-align:center">3.65</td><td style="text-align:center">2.99</td><td style="text-align:center">0.79</td><td style="text-align:center">0.00027</td></tr><tr><td style="text-align:center">电力网络</td><td style="text-align:center">18.70</td><td style="text-align:center">12.40</td><td style="text-align:center">0.080</td><td style="text-align:center">0.005</td></tr><tr><td style="text-align:center">C.elegans</td><td style="text-align:center">2.65</td><td style="text-align:center">2.25</td><td style="text-align:center">0.28</td><td style="text-align:center">0.05</td></tr></tbody></table></div><p>同时满足以上标准的<strong>高聚类系数</strong>和<strong>小平均路径长度</strong>的网络（数学上定义为 $L\propto \log N$，其中 $L$ 是平均路径长度，$N$ 是网络中的节点的总数）称为小型世界网络。</p><h4 id="小世界模型-1"><a href="#小世界模型-1" class="headerlink" title="小世界模型"></a>小世界模型</h4><p>1998年，Duncan J. Watts和Steven Strogatz提出了一个模型，该模型用于构建具有高聚类和较短平均路径长度的网络。他们将此模型称为“小世界模型”。要创建这样的模型，我们采用以下步骤：</p><ol><li><p>低维度的规则格<br>在我们实际的情况中，我们可以将图中的环视为一个格。从低维度的常规环开始，通过将每个节点连接到右侧的 $k$ 个邻居和左侧的 $k$ 个邻居， 其中 $k\geq2$。<br><img src="/images/16164155897022.jpg" alt=""></p></li><li><p>重新连线，生成捷径<br>添加或者删除一些边，依次来将一些“捷径”以概率 $p$ 加入到距离较远的格部分。<br><img src="/images/16164154602809.jpg" alt=""></p></li></ol><p>然后，我们进行以下观察：</p><ul><li>在 $p=0$ 没有发生重新连接边的地方，这仍然是具有高簇集，大直径的网格网络。</li><li>对于 $0&lt;p&lt;1$ ，某些边缘已经进行了重新连线，但是大部分结构仍然保留。这意味着<strong>localoity</strong>和<strong>shortcuts</strong>。</li><li>对于 $p=1$，所有边缘都进行了随机重新连接，这是一个具有低聚类，低直径的ErdősRényi (ER)随机图。</li></ul><p><img src="/images/16164658314955.jpg" alt="clustering_path.png"></p><p>小世界模型通过重新连接概率 $p \in[0,1]$ 来参数化。观察聚类系数和平均路径长度如何随 $p$ 的变化——平均路径长度随着 $p$ 增加而下降得更快，而聚类系数仍然相对较高。重新布线引入了shortcuts，这使得在结构保持相对坚固（高度聚类）的情况下，平均路径长度也可以减小。</p><p>从社交网络的角度来看，这种现象是直观的。虽然我们的大多数朋友都是本地人，但我们在不同国家/地区也有一些远距离的友谊，这足以使人类社交网络的直径崩溃，从而解释了流行的“六度分离”概念。</p><p>Watts-Strogatz小世界模型的两个局限性在于其度的分布与现实网络的幂律分布不匹配，并且由于假定了网络的大小，因此无法对网络的增长进行建模。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>通过小世界模型，只要确定合适的概率p，我们就可以获得一个比较小的图的直径，同时获得比较大的聚类系数。也就是在聚类系数和直径之间做出来一个平衡</li><li>更容易去捕捉局部特征</li><li>由于更高的聚类系数，所以更好的去模拟了真实的网络</li></ol><h3 id="克罗内克-Kroneker-图模型"><a href="#克罗内克-Kroneker-图模型" class="headerlink" title="克罗内克(Kroneker) 图模型"></a>克罗内克(Kroneker) 图模型</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>图生成的模型已被广泛研究。这些模型使我们能够在收集实际图困难时生成用于仿真和假设检验的图，并且还使我们可以检查生成模型应遵循的某些现实属性。</p><p>在制定图生成模型时，有两个重要的考虑因素。首先是生成现实网络的能力，其次是模型的数学易处理性，这允许对网络属性进行严格的分析。</p><p>Kronecker图模型是一个递归图生成模型，结合了数学易处理性和实际的静态和时态网络属性。Kronecker图模型的直观感受是自相似性，整体具有一个或多个部分的形状相同。<br><img src="/images/16164159318930.jpg" alt=""></p><h4 id="Kronecker积"><a href="#Kronecker积" class="headerlink" title="Kronecker积"></a>Kronecker积</h4><p>Kronecker积是一种非标准的矩阵运算，是一种生成自相似矩阵的方法。</p><p>数学上，Kronecker积是两个任意大小矩阵间的运算，表示为 $\otimes$。对于两个任意矩阵 $A \in \mathbb{R}^{m \times n}$ 和 $B \in \mathbb{R}^{p \times q}$， $A\otimes B \in \mathbb{R}^{mp \times nq}$，即：</p><script type="math/tex; mode=display">\textbf{A} \otimes \textbf{B} = \begin{bmatrix}a_{11}\textbf{B} & \dots & a_{1n}\textbf{B} \\\vdots &\ddots & \vdots \\a_{m1}\textbf{B} & \dots & a_{mn}\textbf{B} \\\end{bmatrix}</script><p>例如，</p><script type="math/tex; mode=display">\begin{bmatrix} 1&2\\3&4 \end{bmatrix} \otimes \begin{bmatrix} 0&5\\6&7 \end{bmatrix} = \begin{bmatrix} 1  \begin{bmatrix} 0&5\\6&7 \end{bmatrix}  &2  \begin{bmatrix} 0&5\\6&7 \end{bmatrix}  \\3  \begin{bmatrix} 0&5\\6&7 \end{bmatrix}  &4  \begin{bmatrix} 0&5\\6&7 \end{bmatrix}  \end{bmatrix}= \begin{bmatrix} 1 \times 0 & 1 \times 5 & 2 \times 0 &  2 \times 5\\1 \times 6 & 1 \times 7 & 2 \times 6 &  2 \times 7\\3 \times 0 & 3 \times 5 & 4 \times 0 &  4 \times 5\\3 \times 6 & 3 \times 7 & 4 \times 6 &  4 \times 7\end{bmatrix}= \begin{bmatrix} 0 & 5 & 0 &  10\\6 & 7 & 12 &  14\\0 & 15 & 0 &  20\\18 & 21 & 24 &  28\end{bmatrix}</script><p>为了在图生成中使用Kronecker积，我们将两个图的Kronecker积定义为两个图的邻接矩阵的Kronecker积。</p><p>从初始矩阵$K_{1}$(图的邻接矩阵)开始，我们迭代Kronecker积以生成更大的图</p><script type="math/tex; mode=display">K_{2}=K_{1}\otimes K_{1},K_{3}=K_{2}\otimes K_{1} \dots</script><p>$m$ 阶的Kronecker图定义为</p><script type="math/tex; mode=display">K_{1}^{[m]}=\dots K_{m}=\underbrace{K_1 \otimes K_1 \otimes \dots K_1}_{\text{m times}}=K_{m-1} \otimes K_1</script><p><img src="/images/16164160033041.jpg" alt="small_kronecker"></p><p>直观地，可以将Kronecker幂构造想象为图中的社区的递归增长，其中社区中的节点递归地扩展为社区的微型副本。Kronecker初始矩阵 $K_1$ 的选择可以改变，这会迭代影响较大图形的结构。</p><p><img src="/images/16164159880936.jpg" alt="initiator"></p><h4 id="随机的Kronecker图"><a href="#随机的Kronecker图" class="headerlink" title="随机的Kronecker图"></a>随机的Kronecker图</h4><p>目前，我们仅考虑了具有二进制值 ${0,1}$的初始矩阵 $K_1$。但是，从此类初始矩阵生成的图在度数分布和其他属性中具有“阶梯”效应：由于 $K_1$ 的离散性质，个别值非常频繁地出现。</p><p>为了消除这种影响，通过放宽初<strong>始矩阵中的条目只能采用二进制值</strong>这个假设来引入随机性。取而代之的是可以采用 $[0,1]$ 范围上的值的矩阵 $\Theta_1$，并且每个值都代表该特定边出现的概率。这样矩阵（以及所有生成的较大矩阵乘积）表示该矩阵在所有可能图上的概率分布。</p><p>更具体地说，对于概率矩阵 $\Theta_1$，我们计算 $k^{th}$ Kronecker幂 $\Theta_k$ 作为大型随机邻接矩阵。每个 $\Theta_k$ 中的值 $p_{uv}$ 则代表边 $(u,v)$ 出现的概率。（请注意，概率总和不必为1，因为每个边缘出现的概率与其他边缘无关）</p><p><img src="/images/16164858812539.jpg" alt="stochastic_graphs"></p><p>为了获得图的一个实例，通过以随机邻接矩阵中相应条目给出的概率对每个边进行采样，然后从该分布中进行采样。采样可以被认为是抛具有偏差的硬币的结果，其中偏差被矩阵中的每个条目参数化。</p><p>但是，这意味着简单的生成实例的时间是图形大小的平方，即 $O(N^2)$；当具有100万个节点，我们抛100万$\times$100万次硬币。</p><h4 id="Kronecker-随机图的生成过程"><a href="#Kronecker-随机图的生成过程" class="headerlink" title="Kronecker 随机图的生成过程"></a>Kronecker 随机图的生成过程</h4><p>存在一种快速启发式生成图形的过程，该过程所需时间随着边数量线性变化。</p><p>总体思路可以描述如下：对于每个边缘，我们以概率 $p_{uv} \in \Theta_1$递归地选择大随机矩阵的子区域，直到我们下降到大随机矩阵的单个单元为止。我们将边缘放置在那里。对于Kronecker图的 $k^{th}$ 幂 $\Theta_k$，将需要 $k$ 次下降步骤。</p><p>例如，考虑 $\Theta_1$ 是一个 $2 \times 2$ 的矩阵</p><script type="math/tex; mode=display">\Theta =\begin{bmatrix}a & b \\c & d \end{bmatrix}</script><p>对于具有 $n=2^k$ 个节点的图 $G$</p><ul><li><p>创建归一化矩阵 $L_{uv}=\frac{p_{uv}}{\sum_{u,v}p_{uv}},\quad p_{uv} \in \Theta_1$</p></li><li><p>对于每个边缘：</p><ul><li>For $i=1 \dots k:$<ul><li>初始 $x=0,y=0$</li><li>以概率 $L_{uv}$ 选择行和列</li><li>下降到 $G$ 的第 $i$ 级象限$(u,v)$<ul><li>$x=x+u \cdot 2^{k-1}$</li><li>$y=y+v \cdot 2^{k-1}$</li></ul></li><li>将边 $(x,y)$ 添加到 $G$</li></ul></li></ul></li></ul><p>如果 $k=3$，且对于每一步 $i$，选择象限 $b_{(0,1)},c_{(0,1)},d_{(0,1)}$ 分别基于 $L$ 的归一化概率，有</p><script type="math/tex; mode=display">x=0\cdot 2^{3-1}+1\cdot 2^{3-2}+1\cdot 2^{3-3}=0\cdot 2^2+1\cdot 2^1+1\cdot2^{0}=3\\y=1\cdot 2^{3-1}+0\cdot 2^{3-2}+1\cdot 2^{3-3}=1\cdot 2^2+0\cdot 2^1+1\cdot2^{0}=5</script><p>因此，我们将边$(3,5)$添加到图中。</p><p>在实践中，随机Kronecker图模型能够生成与现实网络的属性非常匹配的图。要阅读有关Kronecker图模型的更多信息，请参阅 <em>J Leskovec et al., Kronecker Graphs: An Approach to Modeling Networks (2010)</em>。</p>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图网络基础——P2.2-随机图</title>
    <link href="/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2-2-%E9%9A%8F%E6%9C%BA%E5%9B%BE/"/>
    <url>/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2-2-%E9%9A%8F%E6%9C%BA%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="随机图算法"><a href="#随机图算法" class="headerlink" title="随机图算法"></a>随机图算法</h3><h4 id="ER随机图算法"><a href="#ER随机图算法" class="headerlink" title="ER随机图算法"></a>ER随机图算法</h4><p>Erdös-Rényi随机图模型是最简单的图模型。这个简单的模型具有经过验证的网络属性，并且是比较实际现实世界图属性的良好基准。<br>此随机图模型有两个变体：</p><ol><li>$G_{np}$: 具有 $n$ 个节点的无向图，并且每条边 $(u,v)$ 出现的概率符合概率为 $p$ 的独立同步分布</li><li>$G_{nm}$: 具有n个节点的无向图，随机地均匀地选择 $m$ 条边</li></ol><p>请注意，$G_{np}$ 和 $ G_{nm}$图不是唯一确定的，而是随机产生的。 在ER生成算法中，通过n个节点和边的生成概率P来生成的无向图不是唯一的，如下图所示：<br><img src="/images/16164044116677.jpg" alt=""><br>根据上图所示，我们可以根据n个节点和概率p来生成不同的边来生成一个随机的图。</p><h4 id="ER图的相关属性"><a href="#ER图的相关属性" class="headerlink" title="ER图的相关属性"></a>ER图的相关属性</h4><h5 id="ER图的度分布"><a href="#ER图的度分布" class="headerlink" title="ER图的度分布"></a>ER图的度分布</h5><p>ER图 $G_{np}$ 的度分布符合二项分布，设 $P(k)$ 表示具有度为 $k$ 的节点数，则</p><script type="math/tex; mode=display">P(k)=\left(\begin{array}{c}n-1 \\k\end{array}\right) p^{k}(1-p)^{n-1-k}</script><p><img src="/images/16164046019276.jpg" alt=""></p><p>如果一个节点的度为 $k$，那么在图中，除了他自身之外就有 $N-1$ 个节点中的 $k$ 个节点需要和其相连接。对于该节点而言，产生一条边的概率为 $p$，并且边的产生是独立同分布的，那么也就是说该点生成 $k$ 条边的概率为 $p^k$，剩余 $n-1-k$ 个节点与该节点没有产生边，那么也就是说其概率为$(1−p)^{n−1−k}$。</p><p>二项分布的均值为：</p><script type="math/tex; mode=display">\bar{k}=p(n-1)</script><p>二项分布的方差为：</p><script type="math/tex; mode=display">\sigma^{2}=p(1-p)(n-1)</script><p>而其标准差和均值的比值为：</p><script type="math/tex; mode=display">\frac{\sigma}{\bar{k}}=\left[\frac{1-p}{p} \frac{1}{n-1}\right]^{1 / 2} \approx \frac{1}{(n-1)^{\frac{1}{2}}}</script><p>二项式分布的一个特性是，根据数字定律，随着网络规模的增加，度的分布原来越集中，分布变得越来越狭窄。也就是说，图中的节点的概率分布越来越接近，节点的度在 $k$ 附近。如果图具有无限个节点，则所有节点将具有相同的度数。（大数分布）</p><p><img src="/images/16164049055536.jpg" alt=""></p><h5 id="ER图的聚类系数"><a href="#ER图的聚类系数" class="headerlink" title="ER图的聚类系数"></a>ER图的聚类系数</h5><p>聚类系数的计算公式为 $C_{i}=\frac{2e_{i}}{k_{i}(k_{i}-1)}$ 其中 $e_{i}$ 是节点 $i$ 的相邻节点之间的边数。因为在 $G_{np}$ 中边出现的概率符合概率为 $p$ 的独立同分布，所以图 $G_{np}$ 中期望的 $e_{i}$ 为</p><script type="math/tex; mode=display">\mathbb{E}\left[e_{i}\right]=p \frac{k_{i}\left(k_{i}-1\right)}{2}</script><p>这是因为 $\frac {k_{i}(k_{i}-1)} {2}$ 是度为 $k_{i}$ 的节点 $i$ 的邻居的不同对的数量，并且每一对以概率 $p$ 相连接。</p><p>因此，期望的聚类系数为：</p><script type="math/tex; mode=display">\mathbb{E}\left[C_{i}\right]=\frac{p \cdot k_{i}\left(k_{i}-1\right)}{k_{i}\left(k_{i}-1\right)}=p=\frac{\bar{k}}{n-1} \approx \frac{\bar{k}}{n}</script><p>$\bar{k}$ 表示平均度，从上面公式可以得到，$G_{np}$ 的聚类系数非常小，如果我们以固定的平均度生成 $\bar{k}$ 一个非常非常大的图，那么 $C$ （即聚类系数）随着规模 $n$ 的增大而减小。$\mathbb{E}\left[C_{i}\right] \rightarrow 0$ as $n \rightarrow \infty$。</p><h5 id="ER图的路径"><a href="#ER图的路径" class="headerlink" title="ER图的路径"></a>ER图的路径</h5><h6 id="扩展因子"><a href="#扩展因子" class="headerlink" title="扩展因子"></a>扩展因子</h6><p>首先定义<strong>扩展系数</strong>的概念。图 $G(V,E)$ 对于 $\forall S \subset V$ 具有扩展系数 $\alpha$ ，剩下的边的数量 $S \geq \alpha \cdot \min (|S|,|V \backslash S|)$。<br>用一个图来展示一下：</p><p><img src="/images/16164119584155.jpg" alt=""><br>扩展系数回答了一个问题，即“如果我们随机选择一组节点，那么有多少条边要离开该组？” 扩展系数是一种鲁棒性的度量：要断开 $\ell \ell$ 个节点，必须切断 $≥\alpha⋅\ell$边缘。<br>同样的，我们也可以认为图 $G(V,E)$ 具有扩展系数 $\alpha$ </p><script type="math/tex; mode=display">\alpha=\min _{S \subset V} \frac{\# \text { edges leaving } S}{\min (|S|,|V \backslash S|)}</script><h6 id="多个随机图结构"><a href="#多个随机图结构" class="headerlink" title="多个随机图结构"></a>多个随机图结构</h6><p>对一个原始的随机图，我们可以将其拆分成多个随机子图，拆分的过程满足我们上面定义的扩展因子的中的公式定义，如下图所示：<br><img src="/images/16164120596236.jpg" alt=""></p><p>关于扩展系数的一个重要事实是，在具有 $n$ 个节点且扩展系数为 $\alpha$ 的图中，对于所有的节点对，将有 $O((\log n)/\alpha)$ 条路径连接他们。对于一个随机的 $G_{np}$ 图，$\log n&gt;n p&gt;c$，所以，$diam(G_{np})=O(\log n/ \log(np))$，因此，我们可以看到随机图具有良好的扩展性，因此BFS访问所有节点的步数为对数。</p><p>我们将原始的n个节点的随机图可以拆分成三个子图，其中子图中的边的数量关系满足我们之前的数量定义。我们以左边的第一图中某一个节点开始，我们寻找其和其他子图中的节点之间的路径，我们不难发现，从某一个节点开始，这种查找的过程很类似于一个树结构。如下图所示：<br><img src="/images/16164121109961.jpg" alt=""></p><p>根据树的特性，两个节点之间的路径的长度是一种对数的长度，也就是说整个图中任意的两个节点之间的最大的路径长度为 $O((\log (n)) / \alpha)$。因此 $G_{np}$ 的路径长度为 $O(\log n)$。尽管随机图中节点数量上涨的很快，但是节点的之间的最短距离的上涨速度通过对数规律，其上涨的速度是很慢的。其上涨的规律如下图所示：</p><p><img src="/images/16164129995570.jpg" alt=""></p><h5 id="ER图的连通子图"><a href="#ER图的连通子图" class="headerlink" title="ER图的连通子图"></a>ER图的连通子图</h5><p>首先，我们先给出关于概率p增长和图的关系，如下图所示：<br><img src="/images/16164131300979.jpg" alt="">从上面的图中，可以确定以下几种情况：</p><ul><li>当 $p$ 的值为$\frac{1}{(n-1)}$ 的时候，会出现巨大的连通子图</li><li>当 $p$ 的值为 $\frac{c}{(n-1)}$ 的时候，会生成大量的孤立点</li><li>当 $p$ 的值为 $\frac{log(n)}{(n-1)}$ 的时候，孤立节点的数量会减少</li><li>当 $p$ 的值为 $\frac{2*log(n)}{(n-1)}$ 的时候，孤立节点消失</li><li>当 $p$ 的值为1的时候，随机图是一个完全图</li></ul><p>$p$ 的均值为 $\frac{k}{(n-1)}$，设定一个阈值 $\epsilon$，有如下的关系：</p><ul><li>$k=1-\epsilon$，所有的子图的规模均在$\Omega(\log n)$</li><li>$\bar{k}=1+\epsilon$，则存在1个连通组件的大小为 $\Omega(n)$，而所有其他组件大小都为 $\Omega(\log n)$<br>用图来展示一下效果，有：<br><img src="/images/16164132021880.jpg" alt=""><h4 id="真实网络和ER随机图的关系总结"><a href="#真实网络和ER随机图的关系总结" class="headerlink" title="真实网络和ER随机图的关系总结"></a>真实网络和ER随机图的关系总结</h4><h5 id="真实网络和ER随机图的关系"><a href="#真实网络和ER随机图的关系" class="headerlink" title="真实网络和ER随机图的关系"></a>真实网络和ER随机图的关系</h5></li><li>对于一个大的连通图而言，其分布和随机图相似</li><li>对于平均的路径长度，真实网络和随机图相似</li><li>聚类系数和度的分布和随机图有所不同</li></ul><h5 id="ER随机图的局限性"><a href="#ER随机图的局限性" class="headerlink" title="ER随机图的局限性"></a>ER随机图的局限性</h5><ul><li>随机图的度分布和真实网络的度分布不同</li><li>真实网络的大的连通子图不是通过随机图的变形来实现的</li><li>由于聚类系数过小，很难去确定一个局部结构</li><li>真实网络并不是一个随机图，我们只能通过这种随机生成的方式去逼近模拟</li></ul><h5 id="随机图的作用"><a href="#随机图的作用" class="headerlink" title="随机图的作用"></a>随机图的作用</h5><ul><li>作为一种比较标准，与真实网络进行比较</li><li>使我们能够了解到，随机过程会影响到图中的某个属性</li></ul>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图网络基础——P2.1-网络属性</title>
    <link href="/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2.1-%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7/"/>
    <url>/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P2.1-%E7%BD%91%E7%BB%9C%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="网络属性"><a href="#网络属性" class="headerlink" title="网络属性"></a>网络属性</h3><p>在本节中，我们将研究关键网络属性以表征图形：<strong>聚类系数</strong>，<strong>节点距离</strong>，<strong>度分布</strong>，<strong>联通子图</strong>和<strong>稳定性</strong>。 这些定义主要是针对无向图的，但可以将其扩展为有向图。</p><h4 id="聚类系数（Cluster-Coefficient）"><a href="#聚类系数（Cluster-Coefficient）" class="headerlink" title="聚类系数（Cluster Coefficient）"></a>聚类系数（Cluster Coefficient）</h4><p>聚类系数(针对无向图)用于衡量节点 $i$ 的邻居所占比例。 </p><h5 id="Local-Cluster-Coefficient"><a href="#Local-Cluster-Coefficient" class="headerlink" title="Local Cluster Coefficient"></a>Local Cluster Coefficient</h5><p>一个节点的聚类参数被称为 Local Cluster Coefficient。它的计算方法也是非常的简单粗暴。先计算所有与当前节点连接的节点中间可能构成的 link 有多少个，这个数会作为分母，然后计算实际上有多少个节点被连接上了，这个数会作为分子。最终的计算结果就是 Local Cluster Coefficient。对于度数为 $k_{i}$的节点 $i$，我们计算聚类系数为</p><script type="math/tex; mode=display">C_{i}=\frac{2e_{i}}{k_{i}(k_{i}-1)}</script><p>其中 $e_{i}$ 是节点 $i$ 的相邻节点之间的边数。 注意 $C_{i}\in[0,1]$ 。 此外，对于度数为0或1的节点，聚类系数是不确定的。</p><h5 id="Global-Cluster-Coefficient"><a href="#Global-Cluster-Coefficient" class="headerlink" title="Global Cluster Coefficient"></a>Global Cluster Coefficient</h5><p>知道了如何计算单个节点的聚类系数，现在来看如何计算整个图的 Cluster Coefficient。</p><p>一种最简单粗暴的方法是，先计算每一个节点的 Local Cluster Coefficient，然后取平均值。</p><p>第二种方法，是先计算在图中已经关闭上的三角形的个数，除上没有闭上的三角形的个数。这种计算方法叫做 Transitivity。这两种方法并没有优劣之分，只是 Transitivity 会倾向于给 degree 大的节点较大的权重。<br><img src="/images/16164025874161.jpg" alt="Transitivity实例"></p><h5 id="平均聚类系数"><a href="#平均聚类系数" class="headerlink" title="平均聚类系数"></a>平均聚类系数</h5><p>同样，可以计算平均聚类系数为：</p><script type="math/tex; mode=display">C=\frac{1}{N}\sum_{i}^{N}C_{i}</script><p>平均聚类系数使我们能够看到边在网络的某些部分是否显得更加密集。 在社交网络中，平均聚类系数趋于很高，表明如我们期望的那样，朋友的朋友倾向于彼此认识。</p><h4 id="节点距离"><a href="#节点距离" class="headerlink" title="节点距离"></a>节点距离</h4><p>路径是一系列节点，其中每个节点都链接到下一个节点：</p><script type="math/tex; mode=display">P_{n}=\left\{i_{0},i_{1},i_{2},...,i_{n}\right\}</script><p>其中 $\left\{(i_{0},i_{1}),(i_{1},i_{2}),(i_{2},i_{3}),…(i_{n-1},i_{n})\right\} \in E$</p><p>一对节点之间的距离(最短路径，geodesic)定义为沿着连接这些节点的最短路径的边数。 如果两个节点未连接，则距离通常定义为无限(或零)。 还可以将距离视为遍历从一个节点到另一个节点所需的最少节点数。为了获得最短距离，通常可以采用图的深度优先遍历，或者广度优先遍历。对于一个较大的网络，想要获得从一个节点到所有节点的距离，会推荐使用 广度优先遍历，因为广度优先遍历可以一层一层的进行计算距离。</p><p>在有向图中，路径需要遵循箭头的方向。 因此，有向图的距离不是对称的。 对于具有加权边的图，距离是从一个节点到另一个节点所需要遍历的最小边权重。</p><p>图的平均路径长度是所有连接的节点之间中最短路径的平均值。 我们将计算平均路径长度定义为</p><script type="math/tex; mode=display">\hat{h}=\frac{1}{2 E_{max }} \sum_{i, j \neq i} h_{i j}</script><p>其中 $E_{max}$ 是边或节点对的最大数目；也就是说 $E_{max}=n(n-1)/2$ 和 $h_{ij}$ 是从 $i$ 节点到 $j$ 节点的距离。注意，我们仅计算连接的节点对上的平均路径长度，因此忽略了无限长度的路径。</p><p>下面是是几个用于描述网络节点距离的参数</p><ul><li>Average distance： 这个很好理解，就是所有两两节点之间的最短距离的平均值，最直接的描述了图的紧密程度</li><li>Eccentricity：这个参数描述的是从任意一个节点，到达其他节点的最大距离</li><li>Diameter：图中的最大两个节点间的距离</li><li>Radius：图中的最小两个节点间的距离</li><li>Periphery： 和 Diameter 对应，那些最大节点距离等于 diameter 的节点</li><li>Center： 和 Radius 对应，那些最大节点距离等于 radius 的节点</li></ul><h4 id="度分布"><a href="#度分布" class="headerlink" title="度分布"></a>度分布</h4><p>度分布 $P(k)$ 表示随机选择的节点具有度 $k$ 的概率。 图 $G$ 的度分布可以通过归一化的直方图来概括，其中我们通过节点总数来归一化直方图。<br><img src="/images/16164042642044.jpg" alt="度分布示意图"></p><p>我们可以通过 $P(k)=N_{k}/N$ 计算图的度分布。其中，$N_{k}$ 是度为 $k$ 的节点数，$N$ 为节点总数。可以将度分布视为随机选择的节点具有度 $k$ 的概率。</p><p>如果要将这些定义扩展为有向图，需要分别计算入度和出度的分布。</p><h4 id="联通子图"><a href="#联通子图" class="headerlink" title="联通子图"></a>联通子图</h4><p>满足子联通图的充分必要条件有两个：</p><ul><li>子连通图中的每个节点都可以有路径可以连接到其他节点</li><li>任何其他非连通图单位的节点都没有路径可以连接到该连通图</li></ul><p>图的连通性可衡量最大连通组件的大小。 最大的连通组件是可以通过路径将任意两个顶点连接在一起的图的最大的集合。</p><p>查找连接的组件：</p><ol><li>从随机节点开始并执行广度优先搜索(BFS)</li><li>标记BFS访问的节点</li><li>如果访问了所有节点，则表明网络是连通的</li><li>否则，找到一个未访问的节点并重复BFS</li></ol><p>这里着重介绍一下在有向图中的两种判断是否为联通图的方式：</p><ol><li>强联通图：每个节点 u 可以到 v，v 也可以到 u。</li><li>弱联通图：只需要 u 可以到 v 即可，可以想象成，满足的条件就是将有向图变成无向图之后是强链接的即可。<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4>图的稳定性表现在，如果我移除任意节点，或者移除任意边，这个图的连接性是否仍然可以保证连通性。</li></ol><p>图的稳定性分析在一些场景中非常有用，举个栗子，比如我们有一个航班图，我们需要分析如果某一个机场意外关闭，或者某一个航班意外取消，这会不会影响出行。 所以图的稳定性分析实际上描述的是一个图抵抗攻击的能力。同样的应用场景还有，电力网络，互联网攻击等。</p><p>那么如何定量的描述一个网络的稳定性呢，两个指标：</p><ol><li>断开一个网络需要的最少的 Node Cuts</li><li>断开一个网络需要的最少的 Edge Cuts</li></ol><p><img src="/images/16164037125574.jpg" alt=""><br>如上图所示，如果我们移除网络中的 A 节点，这个网络就会断开。</p><p>除了断开一个网络，有的时候我们也需要分析 A 节点到 B 节点之间的连接的稳定性，分析链接的稳定的指标也非常类似以上：</p><ol><li>断开两个节点的链接需要的最少的 Node Cuts</li><li>断开两个节点的链接需要的最少的 Edge Cuts<br><img src="/images/16164037337473.jpg" alt=""><br>如上图所示，如果我们移除网络中的 A$\rightarrow$N 和 J$\rightarrow$O 连接，G$\rightarrow$L 的连接将会断开。</li></ol>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图网络基础——P1-Introduction and Graph Structure</title>
    <link href="/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P1-Introduction%20and%20Graph%20Structure/"/>
    <url>/2021/03/22/%E5%9B%BE%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94P1-Introduction%20and%20Graph%20Structure/</url>
    
    <content type="html"><![CDATA[<h3 id="图的基本介绍和图结构"><a href="#图的基本介绍和图结构" class="headerlink" title="图的基本介绍和图结构"></a>图的基本介绍和图结构</h3><p>网络成为了用于描述复杂系统中交互实体的通用语言。从图片上讲，与其认为我们的数据集由一组孤立的数据点组成，不如考虑这些点之间的相互作用和关系。</p><p>在不同种类的网络之间进行哲学上的区分是有启发性的。对网络的一种解释是作为现实生活中出现的现象的例子。我们称这些网络为<em>自然图</em>。像如下例子：</p><ul><li>人类社交网络(70+亿个人的集合)</li><li>互联网通信系统(电子设备的集合)</li></ul><p>网络的另一种解释是作为一种数据结构，可用于解决特定的预测问题。在这种情况下，我们对实体之间的关系更感兴趣，因此我们可以有效地执行学习任务。我们称这些网络为<em>信息图</em>，比如：</p><ul><li>场景图(场景中的对象如何相互关联)</li><li>相似性网络(其中连接了数据集中的相似点)</li></ul><p>在本部分内容，我们将主要介绍一些图的基础知识，希望能够通过图的显式建模关系以获得更好的预测性能。此类预测性任务的一些示例包括：</p><ol><li><em>节点分类</em>，我们在其中预测给定节点的类型/颜色</li><li><em>链接预测</em>，我们在其中预测两个节点是否链接</li><li><em>社区检测</em>，我们在其中识别密集链接的节点簇</li><li><em>相似度计算</em>，我们在其中测量两个节点或网络的相似度</li></ol><p>总而言之，<strong>网络是一种用于描述复杂数据的通用语言</strong>，并且可以应用于各种不同的领域。随着数据可用性的提高和各种计算挑战，学习了解网络可以使人们有能力做出各种各样的贡献。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>网络/图形（从技术上讲，网络通常是指真实的系统(网络，社交网络等)，而图形通常是指网络的数学表示形式(网络图，社会图等)。 在这些笔记中，我们将互换使用这些术语。）被定义为对象的集合，其中一些对象对通过链接连接。我们将对象(节点)的集合定义为 $N$， 对象之间的交互(边/链接)定义为 $E$， 将图形定义为 $G(N,E)$。</p><p><strong>无向图</strong>具有对称/双向链接(例如，Facebook上的朋友关系)。我们定义节点度 $k_{i}$ 为无向图中与节点 $i$ 相邻的边数。那么平均程度是</p><script type="math/tex; mode=display">\bar{k}=\langle k\rangle=\frac{1}{|N|} \sum_{i=1}^{|N|} k_{i}=\frac{2|E|}{N}</script><p><strong>有向图</strong>具有定向链接(例如，在Twitter上关注)。我们定义入度 $k_{i}^{in}$ 为进入节点 $i$ 的边数。同样，我们定义出度 $k_{i}^{out}$ 为离开节点 $i$ 的边数。</p><script type="math/tex; mode=display">\bar{k}=\langle k\rangle=\frac{|E|}{N}</script><p><strong>完全图</strong>，具有最大数量的边的无向图称为完全图(这样所有节点对都被连接)。完全图有 $|E|=\left(\begin{array}{l}N\\2\end{array}\right)=\frac{N(N-1)}{2}$ 条边，并且平均度为 $|N|-1$ 。</p><p><strong>二分图</strong>，二分图是其节点可以分为两个不相交的集和 $U$ 和 $V$，使得每个边都连接一个集合 $U$ 的节点和一个集合 $V$ 的节点（也就是说，集合 $U$ 内的节点没有边，集合 $V$ 内的节点没有边，我们称 $U$和 $V$  为独立的集合）。如果独立集合 $U$ 和 $V$ 共享至少一个共同的邻居，我们可以通过在独立集合中创建边来“折叠”二分图。<br>在这里，如果集合 $U$ 中的节点至少共享一个在 集合 $V$ 中的邻居节点，则集合 $U$  中的节点将相连形成投影 $U$，采用相同的过程来获得投影 $V$。<br><img src="/images/16164606916214.jpg" alt=""></p><h4 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h4><p>我们使用<strong>邻接矩阵</strong> $A$ 来表示图 $G$， 其中 $A_{ij}=1$ 表示节点 $i$ 和 $j$ 相连(如果 $A_{ij}=0$ 则表示没有相邻边)。对于有向图则 $A$ 是不对称的。例如，一个4节点的有向图的邻接矩阵可以表示为</p><script type="math/tex; mode=display">A=\left[\begin{array}{llll}0 & 1 & 0 & 1 \\ 1 & 0 & 0 & 1 \\ 0 & 0 & 0 & 1 \\ 1 & 1 & 1 & 0\end{array}\right]</script><p>对于无向图，</p><script type="math/tex; mode=display">k_{i}=\sum_{j=1}^{|N|} A_{i j} \quad \text { and } \quad k_{j}=\sum_{i=1}^{|N|} A_{i j}</script><p>同样，对于有向图，</p><script type="math/tex; mode=display">k_{i}^{out}=\sum_{j=1}^{|N|} A_{i j} \quad \text { and } \quad k_{j}^{in}=\sum_{i=1}^{|N|} A_{i j}</script><p>但是，大多数现实世界的网络都很稀疏( $|E| \ll E_{max}$ ,or $\bar{k} \ll |N|-1$ )，结果导致邻接矩阵被大量的零填充。</p><p>为了缓解此问题，我们可以将图表示为一组边的集合，从而节省了内存，但是这样使得边的查找困难。</p><h4 id="图的连通"><a href="#图的连通" class="headerlink" title="图的连通"></a>图的连通</h4><p>如果无向图 $G$ 图中任意一对节点之间存在路径，则我们称 $G$ 为<strong>强连通图</strong>。<strong>非强连通图</strong>由两个或多个连接的组件组成。如果移除某一条边将强连通图变为非强连通图，我们称这条边为<strong>桥边</strong>；<strong>关键节点</strong>是指移除改节点后导致强连通图变为非强连通图的节点。具有多个组成部分的网络邻接矩阵可以按块对角线的形式编写(这样，非零元素将被限制为正方形，而所有其他元素均为0)。</p><p>我们可以将这些概念进一步扩展到有向图，将强连接的有向图定义为一个有从某个节点到任何其他节点的路径的图，反之亦然，(即同时具有A→B和B→A的路径)。如果忽略边的方向，则将形成一个弱连接的有向图。我们进一步将<strong>强连接组件(SCCs)</strong>定义为 $G$ 的<strong>强连接子图</strong>。可以到达SCC的节点是其内部组件的一部分，可以从SCC到达的节点是其外部组件的一部分。</p><p>下图虽然已连接但不是强连接图，包含了一个SCC(图 $G’=G[A,B,C]$ )。</p><p><img src="/images/16164606555734.jpg" alt="introduction_directed_graph"></p>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日常笔记</tag>
      
      <tag>总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>反爬策略总结</title>
    <link href="/2021/02/23/%E5%8F%8D%E7%88%AC%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/"/>
    <url>/2021/02/23/%E5%8F%8D%E7%88%AC%E7%AD%96%E7%95%A5%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>简单低级的爬虫速度快，伪装度低，如果没有反爬机制，它们可以很快的抓取大量数据，甚至因为请求过多，造成服务器不能正常工作。而伪装度高的爬虫爬取速度慢，对服务器造成的负担也相对较小。所以，网站反爬的重点也是那种简单粗暴的爬虫，反爬机制也会允许伪装度高的爬虫，获得数据。毕竟伪装度很高的爬虫与真实用户也就没有太大差别了。<br>如何应对普通的反爬机制，主要有三个方法：<br>1、header检验<br>2、用户异常行为：IP/账号<br>3、动态加载页面</p><h3 id="1-header检验"><a href="#1-header检验" class="headerlink" title="1.header检验"></a>1.header检验</h3><p>最简单的反爬机制，就是检查HTTP请求的Headers信息，包括User-Agent，Referer，Cookies等。</p><h4 id="User-Agent"><a href="#User-Agent" class="headerlink" title="User-Agent"></a>User-Agent</h4><p>User-Agent是检查用户所用客户端的种类和版本，在Scrapy中，通常是在下载器中间件中进行处理。比如在setting.py中建立一个包含很多浏览器User-Agent的列表，然后新建一个random_user_agent文件。</p><h4 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h4><p>Referer是检查此请求由哪里来，通常可以做图片的盗链判断。在Scrapy中，如果某个页面url是通过之前爬取的页面提取到，Scrapy会自动把之前爬取的页面url作为Referfer。也可以通过上面的方式自己定义Referfer字段。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>网站可能会检测Cookie中session_id的使用次数，如果超过限制，就触发反爬策略。所以可以在Scrapy中设置COOKIES_ENABLED = False让请求不带Cookies。也有网站强制开启Cookis，这时就要麻烦一点了。可以另写一个简单的爬虫，定时向目标网站发送不带Cookies的请求，提取响应中Set-cookie字段信息并保存。爬取网页时，把存储起来的Cookies带入Headers中。</p><h3 id="2-用户异常行为"><a href="#2-用户异常行为" class="headerlink" title="2.用户异常行为"></a>2.用户异常行为</h3><h4 id="限制IP的请求数量："><a href="#限制IP的请求数量：" class="headerlink" title="限制IP的请求数量："></a>限制IP的请求数量：</h4><p>使用IP代理就可以解决。可以专门写一个爬虫，爬取网上公开的代理ip，检测后全部保存起来。这样的代理ip爬虫经常会用到，最好自己准备一个。有了大量代理ip后可以每请求几次更换一个ip，这在requests或者urllib2中很容易做到，这样就能很容易的绕过第一种反爬虫。</p><h4 id="同一账户短时间内多次进行相同操作："><a href="#同一账户短时间内多次进行相同操作：" class="headerlink" title="同一账户短时间内多次进行相同操作："></a>同一账户短时间内多次进行相同操作：</h4><p>可以在每次请求后随机间隔几秒再进行下一次请求。有些有逻辑漏洞的网站，可以通过请求几次，退出登录，重新登录，继续请求来绕过同一账号短时间内不能多次进行相同请求的限制</p><h3 id="3-动态加载页面："><a href="#3-动态加载页面：" class="headerlink" title="3.动态加载页面："></a>3.动态加载页面：</h3><p>一部分网站，需要爬取的数据是通过ajax请求得到，或者通过JavaScript生成的。首先用Firebug或者HttpFox对网络请求进行分析。如果能够找到ajax请求，也能分析出具体的参数和响应的具体含义，就能采用上面的方法，直接利用requests或者urllib2模拟ajax请求，对响应的json进行分析得到需要的数据。<br>解决方案：用selenium+phantomJS框架，调用浏览器内核，并利用phantomJS执行js来模拟人为操作以及触发页面中的js脚本</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://www.jianshu.com/p/af7027ba68cc">https://www.jianshu.com/p/af7027ba68cc</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>反爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python爬取音视频节目</title>
    <link href="/2021/02/23/Python%E7%88%AC%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%8A%82%E7%9B%AE/"/>
    <url>/2021/02/23/Python%E7%88%AC%E5%8F%96%E9%9F%B3%E8%A7%86%E9%A2%91%E8%8A%82%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>今天做了爬取音视频节目的实验，主要针对两类：一是固有链接的音视频节目，二是非固有链接的音视频节目，现总结相关内容如下：</p><h1 id="固有链接的音视频节目"><a href="#固有链接的音视频节目" class="headerlink" title="固有链接的音视频节目"></a>固有链接的音视频节目</h1><p>这类网站一般搭建的比较简单，直接获取音视频节目的链接进行保存即可。<br>例子：<a href="https://www.thepaper.cn/list_26913">https://www.thepaper.cn/list_26913</a>  <a href="https://haokan.baidu.com/">https://haokan.baidu.com/</a></p><h1 id="非固有链接的音视频节目（以-B-站为例）"><a href="#非固有链接的音视频节目（以-B-站为例）" class="headerlink" title="非固有链接的音视频节目（以 B 站为例）"></a>非固有链接的音视频节目（以 B 站为例）</h1><p>这类音视频节目的获取需要考虑三点:</p><ol><li>CDN：一个音视频节目是否从多个 CDN 上进行获取；</li><li>反爬策略：构造requests请求的时候需要考虑头部信息，比如 Referer和UserAgent</li><li>音视频整合：B 站爬取得到的是音频和视频内容，分别获取之后需要使用工具进行整合</li></ol><h2 id="系统结构"><a href="#系统结构" class="headerlink" title="系统结构"></a>系统结构</h2><h3 id="使用到的工具"><a href="#使用到的工具" class="headerlink" title="使用到的工具"></a>使用到的工具</h3><ol><li>IntelliJ IDEA 2019.1.4</li><li>Python3.8（编程语言）</li><li>requests库（发送http请求）</li><li>lxml库（xpath解析）</li><li>json库（解析json数据）</li><li>ffmpeg（合并音频和视频）<br><img src="/images/16140769041473.jpg" alt="系统数据包库"></li></ol><h3 id="功能实现原理"><a href="#功能实现原理" class="headerlink" title="功能实现原理"></a>功能实现原理</h3><ol><li>输入 BV 开头音视频节目编号拼接成为有效的包含音视频节目的 url</li><li>构造 request 请求访问视频页面，得到页面的响应信息</li><li>使用 lxml 库与 json 库从返回的响应信息中提取到视频资源的链接</li><li>模拟浏览器请求获取音频和视频资源</li><li>将获得的音频和视频资源合并保存到本地（ffmpeg）</li></ol><h2 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h2><h3 id="了解url结构"><a href="#了解url结构" class="headerlink" title="了解url结构"></a>了解url结构</h3><p>到 Bilibili 首页随便点开一个音视频节目，观察节目的 URL，可以看到该 url 包含一个正常的文件路径和一个参数 p 。<br><img src="/images/16140789360741.jpg" alt="-w364"></p><p><img src="/images/16140774185038.jpg" alt="节目的 URL"><br>其中，URL 由 B 站主站域名 + video + 节目编号 + 参数 p 节目集数组成。<br>有些节目没有选集，则不需要参数 P，构造获取网页信息的时候不添加该参数即可。</p><h3 id="解析网页，找到下载视频的链接"><a href="#解析网页，找到下载视频的链接" class="headerlink" title="解析网页，找到下载视频的链接"></a>解析网页，找到下载视频的链接</h3><p>打开开发者工具，查找页面元素<code>window.__playinfo__</code>，找到在head标签的第4个 script 标签里面存有视频播放信息，<code>baseUrl</code> 即为视频资源链接<br><img src="/images/16140777507567.jpg" alt="网页结构解析"><br><img src="/images/16140779900604.jpg" alt="视频资源 url"></p><h3 id="下载视频与音频"><a href="#下载视频与音频" class="headerlink" title="下载视频与音频"></a>下载视频与音频</h3><p>去查看视频资源的网络请求，发现一共有两种请求方式，一种是 GET，另一种是 OPTION。视频资源可能需要先发送 OPTION 请求，获取服务器许可后再请求资源，许可的保持时间较长，所以只发一次 OPTION 请求就可以了。<br><img src="/images/16140782219165.jpg" alt="GET"></p><p><img src="/image/16140782012809.jpg" alt="OPTION"></p><p>这里有两种下载视频的方式：<br>第一种是利用416报错码分片下载，Referer用于写明来源，Range用于规定分片的字节大小以及范围，每下载一定字节的资源，就修改Range，直到最后一次字节数大于剩下的资源时，服务器返回416报错，再重新将Range设置为’Range’: ‘bytes=上一次开始的索引-’。把最后剩下的资源下载下来。每获得一个视频的分片就给他拼接到文件最后，最后得到完整文件。这里使用的是第二种方法，得到了音频和视频两个文件。<br>第二种是不加入Range参数，直接下载整个的音频与视频，只需要注释掉添加请求头Range参数的语句即可。</p><h3 id="合并视频与音频"><a href="#合并视频与音频" class="headerlink" title="合并视频与音频"></a>合并视频与音频</h3><p>对于 Bilibili 2018年以后的视频需要再多一步音频与视频合并的操作，这里通过 ffmpeg 来实现这个功能。安装 ffmpeg 参考45。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>以下代码在参考文献1的基础上进行略微修改，修改部分：combineVideoAudio 函数的命令行输出和 getBiliBiliVideo 函数中 Xpath 定位部分。另外原文是在 Windows 系统下进行的实验，本文在 MAC OS下，因此部分文件路径描述相关问题也有修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> subprocess<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> lxml <span class="hljs-keyword">import</span> etree<br><br><span class="hljs-comment"># 防止因https证书问题报错</span><br>requests.packages.urllib3.disable_warnings()<br>headers = &#123;<span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.182 Safari/537.36&#x27;</span>,<br>    <span class="hljs-string">&#x27;Referer&#x27;</span>: <span class="hljs-string">&#x27;https://www.bilibili.com/&#x27;</span>&#125;<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    获取bilibili视频的主要函数</span><br><span class="hljs-string">    @param url 视频页面url 结构为:url?参数</span><br><span class="hljs-string">    @param p 视频p数</span><br><span class="hljs-string">    @param bv 视频bv数</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getBiliBiliVideo</span>(<span class="hljs-params">url, p, bv</span>):</span><br>    session = requests.session()<br>    res = session.get(url=url, headers=headers, verify=<span class="hljs-literal">False</span>)<br>    _element = etree.HTML(res.content)<br>    <span class="hljs-comment"># 获取window.__playinfo__的json对象,[20:]表示截取&#x27;window.__playinfo__=&#x27;后面的json字符串</span><br>    <span class="hljs-comment"># videoPlayInfo = str(_element.xpath(&#x27;//head/script[3]/text()&#x27;)[0].encode(&#x27;utf-8&#x27;).decode(&#x27;utf-8&#x27;))[20:]</span><br>    videoPlayInfo = <span class="hljs-built_in">str</span>(_element.xpath(<span class="hljs-string">&#x27;//head/script[5]/text()&#x27;</span>)[<span class="hljs-number">0</span>].encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>).decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))[<span class="hljs-number">20</span>:]<br>    videoJson = json.loads(videoPlayInfo)<br>    <span class="hljs-comment"># 获取视频链接和音频链接</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 2018年以后的b站视频由.audio和.video组成</span><br>        videoURL = videoJson[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;video&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>        audioURl = videoJson[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;dash&#x27;</span>][<span class="hljs-string">&#x27;audio&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;baseUrl&#x27;</span>]<br>        flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-comment"># 2018年以前的b站视频音频视频结合在一起,后缀为.flv</span><br>        videoURL = videoJson[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-string">&#x27;durl&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;url&#x27;</span>]<br>        flag = <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 指定文件生成目录,如果不存在则创建目录</span><br>    dirname = (<span class="hljs-string">&quot;./result&quot;</span>).encode(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(dirname):<br>        os.makedirs(dirname)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;文件夹创建成功!&#x27;</span>)<br>    <span class="hljs-comment"># 获取每一集的名称</span><br>    name = bv + <span class="hljs-string">&quot;-&quot;</span> + <span class="hljs-built_in">str</span>(p)<br>    <span class="hljs-comment"># 下载视频和音频</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在下载 &quot;&#x27;</span> + name + <span class="hljs-string">&#x27;&quot; 的视频····&#x27;</span>)<br>    fileDownload(homeurl=url, url=videoURL, name=<span class="hljs-string">&#x27;./result/&#x27;</span> + name + <span class="hljs-string">&#x27;_Video.mp4&#x27;</span>, session=session)<br>    <span class="hljs-keyword">if</span> flag == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在下载 &quot;&#x27;</span> + name + <span class="hljs-string">&#x27;&quot; 的音频····&#x27;</span>)<br>        fileDownload(homeurl=url, url=audioURl, name=<span class="hljs-string">&#x27;./result/&#x27;</span> + name + <span class="hljs-string">&#x27;_Audio.mp3&#x27;</span>, session=session)<br>        <span class="hljs-comment"># 组合音视频</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在组合 &quot;&#x27;</span> + name + <span class="hljs-string">&#x27;&quot; 的视频和音频····&#x27;</span>)<br>        combineVideoAudio(<span class="hljs-string">&#x27;./result/&#x27;</span> + name + <span class="hljs-string">&#x27;_Video.mp4&#x27;</span>,<br>                          <span class="hljs-string">&#x27;./result/&#x27;</span> + name + <span class="hljs-string">&#x27;_Audio.mp3&#x27;</span>,<br>                          <span class="hljs-string">&#x27;./result/&#x27;</span> + name + <span class="hljs-string">&#x27;_output.mp4&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27; &quot;&#x27;</span> + name + <span class="hljs-string">&#x27;&quot; 下载完成！&#x27;</span>)<br><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    使用session保持会话下载文件</span><br><span class="hljs-string">    @param homeurl 访问来源</span><br><span class="hljs-string">    @param url 音频或视频资源的链接</span><br><span class="hljs-string">    @param name 下载后生成的文件名</span><br><span class="hljs-string">    @session 用于保持会话</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fileDownload</span>(<span class="hljs-params">homeurl, url, name, session=requests.session(<span class="hljs-params"></span>)</span>):</span><br>    <span class="hljs-comment"># 添加请求头键值对,写上 refered:请求来源</span><br>    headers.update(&#123;<span class="hljs-string">&#x27;Referer&#x27;</span>: homeurl&#125;)<br>    <span class="hljs-comment"># 发送option请求服务器分配资源</span><br>    session.options(url=url, headers=headers, verify=<span class="hljs-literal">False</span>)<br>    <span class="hljs-comment"># 指定每次下载1M的数据</span><br>    begin = <span class="hljs-number">0</span><br>    end = <span class="hljs-number">1024</span> * <span class="hljs-number">512</span> - <span class="hljs-number">1</span><br>    flag = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># 添加请求头键值对,写上 range:请求字节范围</span><br>        headers.update(&#123;<span class="hljs-string">&#x27;Range&#x27;</span>: <span class="hljs-string">&#x27;bytes=&#x27;</span> + <span class="hljs-built_in">str</span>(begin) + <span class="hljs-string">&#x27;-&#x27;</span> + <span class="hljs-built_in">str</span>(end)&#125;)<br>        <span class="hljs-comment"># 获取视频分片</span><br>        res = session.get(url=url, headers=headers, verify=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> res.status_code != <span class="hljs-number">416</span>:<br>            <span class="hljs-comment"># 响应码不为为416时有数据</span><br>            begin = end + <span class="hljs-number">1</span><br>            end = end + <span class="hljs-number">1024</span> * <span class="hljs-number">512</span><br>        <span class="hljs-keyword">else</span>:<br>            headers.update(&#123;<span class="hljs-string">&#x27;Range&#x27;</span>: <span class="hljs-built_in">str</span>(end + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;-&#x27;</span>&#125;)<br>            res = session.get(url=url, headers=headers, verify=<span class="hljs-literal">False</span>)<br>            flag = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(name.encode(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>), <span class="hljs-string">&#x27;ab&#x27;</span>) <span class="hljs-keyword">as</span> fp:<br>            fp.write(res.content)<br>            fp.flush()<br>        <span class="hljs-comment"># data=data+res.content</span><br>        <span class="hljs-keyword">if</span> flag == <span class="hljs-number">1</span>:<br>            fp.close()<br>            <span class="hljs-keyword">break</span><br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    用于合并音频与视频</span><br><span class="hljs-string">    @param videopath 视频路径</span><br><span class="hljs-string">    @param audiopath 音频路径</span><br><span class="hljs-string">    @param outpath 生成合并视频的路径</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">combineVideoAudio</span>(<span class="hljs-params">videopath, audiopath, outpath</span>):</span><br>    <span class="hljs-comment"># ffmpeg -i videopath -i audiopath -c:v copy -c:a aac -strict experimental outpath</span><br>    command1 = <span class="hljs-string">&#x27;ffmpeg -i &#x27;</span> + videopath + <span class="hljs-string">&#x27; -i &#x27;</span> + audiopath + <span class="hljs-string">&#x27; -c:v copy -c:a aac -strict experimental &#x27;</span> + outpath<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./result/output.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        subprocess.check_call(command1.encode(<span class="hljs-string">&quot;utf-8&quot;</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>), stderr=file, shell=<span class="hljs-literal">True</span>)<br>    os.remove(videopath)<br>    os.remove(audiopath)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 输入bilibili视频的BV号 BV1nE411y76r</span><br>    bv = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;视频BV号: &#x27;</span>)<br>    url = <span class="hljs-string">&#x27;https://www.bilibili.com/video/&#x27;</span> + bv<br>    <span class="hljs-comment"># 选择视频从第几p开始到第几p结束</span><br>    startPart = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;起始P: &#x27;</span>)<br>    endPart = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;终止P: &#x27;</span>)<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(startPart), <span class="hljs-built_in">int</span>(endPart) + <span class="hljs-number">1</span>):<br>        getBiliBiliVideo(url + <span class="hljs-string">&#x27;?p=&#x27;</span> + <span class="hljs-built_in">str</span>(p), p, bv)<br></code></pre></td></tr></table></figure><p>例子：<a href="https://www.bilibili.com/video/BV1nE411y76r?p=1">https://www.bilibili.com/video/BV1nE411y76r?p=1</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>如何使用Python爬取bilibili视频（详细教程）<a href="https://zhuanlan.zhihu.com/p/148988473">https://zhuanlan.zhihu.com/p/148988473</a></li><li>页面元素定位 XPath 简介 <a href="https://www.cnblogs.com/feeland/p/4829093.html">https://www.cnblogs.com/feeland/p/4829093.html</a></li><li>Python - 调用终端执行命令 <a href="https://www.aiuai.cn/aifarm949.html">https://www.aiuai.cn/aifarm949.html</a></li><li>FFmpeg的安装和测试 <a href="https://www.jianshu.com/p/0b1c98a28fd4">https://www.jianshu.com/p/0b1c98a28fd4</a></li><li>用ffmpeg合并音频和视频 <a href="https://www.zhihu.com/question/300182407">https://www.zhihu.com/question/300182407</a></li></ol><p>以下是不太重要的资料：</p><ol><li>各种网站视频下载方法 <a href="https://blog.csdn.net/liujiayu2/article/details/86137139">https://blog.csdn.net/liujiayu2/article/details/86137139</a></li><li>下载有固定链接的视频 <a href="https://blog.csdn.net/liujiayu2/article/details/86016531">https://blog.csdn.net/liujiayu2/article/details/86016531</a></li><li>批量抓取网页上的视频 <a href="https://blog.csdn.net/u012162613/article/details/41611889">https://blog.csdn.net/u012162613/article/details/41611889</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>日常笔记</category>
      
      <category>代码</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>音视频</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>First Blog</title>
    <link href="/2021/02/11/first-blog/"/>
    <url>/2021/02/11/first-blog/</url>
    
    <content type="html"><![CDATA[<p>这是我的第一篇博客。<br>    今天是传统的节日———春节！在这里祝愿大家新年快乐~</p>]]></content>
    
    
    <categories>
      
      <category>简介</category>
      
    </categories>
    
    
    <tags>
      
      <tag>介绍</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
